<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Asp.net Core on The full cycle developer blog</title><link>https://fullcycledeveloper.com</link><description>Recent content in Asp.net Core on The full cycle developer blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 18 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://fullcycledeveloper.com/tags/asp.net-core/index.xml" rel="self" type="application/rss+xml"/><item><title>Platform Engineering? It's just DevOps!</title><link>https://fullcycledeveloper.com/2022/11/17/platform-engineering-is-just-devops/</link><pubDate>Thu, 17 Nov 2022 00:00:00 +0000</pubDate><guid>https://fullcycledeveloper.com/2022/11/17/platform-engineering-is-just-devops/</guid><description>&lt;p>The software industry has a reputation butchering great ideas into things that we call the same but in the end are being mis-used completely compared to the initial concepts. Take &amp;ldquo;Agile&amp;rdquo;. Everyone is working sprints or using Kanban but a lot of companies are far from actual the actual agile concepts. People use Jira so they are Agile. Same goes for DevOps where a lot of traditional operations teams were rebranded to ops so now they do devops ðŸ¤· , Microservices: just cut your monolith into pieces so you get a large distributed monolith which isn&amp;rsquo;t better than the monolith ðŸ¤·.&lt;/p>
&lt;p>The problem is often that vendors try to help out with certain problems and then companies think they can just buy Agile by using Jira, You can buy DevOps by using Azure DevOps, Github or Gitlab. A lot of software vendors enable you do do these things better but it&amp;rsquo;s far more than just these tools. It&amp;rsquo;s also they way you work, communicate and your internal operating model.&lt;/p>
&lt;p>One of the latest hypes is &amp;ldquo;Platform Engineering&amp;rdquo;. The idea behind it is pretty good (I&amp;rsquo;ll come back to that in a moment) but the term is already broken before most people actually know what it is because vendors who create &amp;ldquo;platform engineering tools&amp;rdquo; butcher the term Platform Engineering. Slogans as &amp;ldquo;DevOps is dead, use Platform Engineering&amp;rdquo; totally miss the point. It&amp;rsquo;s NOT another rebrand of your operations department after rebranding it to DevOps or SRE. In my humble opinion the only thing that matters is setting up an organizational structure that works best FOR YOUR COMPANY (which is different from all other companies so stop copy pasting things from other companies without thinking what works for you).&lt;/p>
&lt;blockquote>
&lt;p>TLDR: I see DevOps as a way of working that you could implement in several ways. Platform Engineering and SRE are implementations of this.&lt;/p>
&lt;/blockquote>
&lt;p>
&lt;img src="https://fullcycledeveloper.com/img/platform-engineering-meme.jpg" alt="Platform Engineering meme">
&lt;/p>
&lt;h3 id="devops-sre-platform-engineering">DevOps, SRE, Platform Engineering?&lt;/h3>
&lt;p>Since our industry is changing super fast most terms don&amp;rsquo;t have an official description that everyone agrees on. So to at least be talking about the same thing here I&amp;rsquo;ll drop my definitions of DevOps, SRE and Platform engineering here so that you know where I come from comparing them.&lt;/p>
&lt;h3 id="devops">DevOps&lt;/h3>
&lt;p>DevOps, a term used for quite a while now in our industry. There are a lot of different opinions about what DevOps is. To me it is much more than just putting some devs and operations people together. It&amp;rsquo;s about creating autonomous teams who focus on delivering business value in a better &amp;amp; faster way. It&amp;rsquo;s a combination of People, processes and tools all working together for the goal of delivering a better product faster.&lt;/p>
&lt;p>Autonomy in this is key. Giving a lot of freedom to teams to live the mantra: &amp;ldquo;You build it, you run it.&amp;rdquo; This means teams should have the capabilities and responsibilty to make decisions themselves on almost everything. The software they build, the cloud infrastructure they run on, the network that connects their components, the database that stores their data..&lt;/p>
&lt;p>These autonomous teams have proven to be highly effective but they also come with a burder. Engineers now need to know more from a lot of things instead of only focus on the code they write. SRE and Platform engineering are forms that can help release this burden.&lt;/p>
&lt;h3 id="sre">SRE&lt;/h3>
&lt;p>SRE, (Site Reliability Engineering) Invented by Google is a way to add extra reliability to software products by having engineering teams who focus mainly on Reliability. This does not mean that they fix issues for DevOps teams but they are truely engineers who have a lot of expertise in creating reliable software products and can help the DevOps team in improving the way their product works from a reliability perspective.&lt;/p>
&lt;p>At Google DevOps teams need to earn the addition of a SRE team for their product by proving their product is delivering enough business value.&lt;/p>
&lt;p>In this definition of SRE, SRE should not be compared to DevOps. It is just a way of implementing DevOps for large organizations releasing some of the burden of creating high reliable software products when products need to scale to the immense scale of a company like Google.&lt;/p>
&lt;h3 id="platform-engineering">Platform Engineering&lt;/h3>
&lt;p>Platform Engineering teams, the newest hype in creating high performing software organizations should be a similar addition to implementing DevOps if you ask me. The core principle is also releasing the burden of the DevOps teams by creating standardized software platforms that autonomous DevOps teams &lt;em>can&lt;/em> use. This can be all kinds of products like container hosting platforms, firewall &amp;amp; network controlls, API Management, Cloud infrastructure platforms, DevOps tooling platforms, you name it.&lt;/p>
&lt;p>What I don&amp;rsquo;t like about the current platform engineering hype is that there is a really large push on platform engineering products who also mainly focus on kubernetes. Platform engineering teams should NOT be about pushing a platform to autonomous DevOps teams but should rather be ran as an internal product team who&amp;rsquo;s product can be used by DevOps teams if they think this would be a great fit for them.&lt;/p>
&lt;p>If DevOps teams would decide not to use the platform that should be just fine! The platform engineering team should create a product that actually delivers value to the DevOps teams and not burden them in such a way that might hinder the DevOps team to deliver business value.&lt;/p>
&lt;h3 id="who-needs-platform-engineering">Who needs Platform Engineering?&lt;/h3>
&lt;p>In current times where we build modern software I think there is a great place for platform engineering. Autonomous DevOps teams have to focus on so many things that require extra expertise and knowledge that it makes it harder and harder to execute. In these cases Platform engineering can be the answer to make the DevOps teams working on a certain value stream focus more on the actual value tream and use services provided by the platform engineering team.&lt;/p>
&lt;p>Platform engineering teams can also focus a lot more in getting to know all the details and focus on tuning underlying infrastructure or software where a DevOps team focussing on a business value stream does not have time for. Key thing here is though that they should never become a bottleneck for these DevOps teams.&lt;/p>
&lt;p>Some examples I&amp;rsquo;ve seen &amp;amp; helped build at companies:&lt;/p>
&lt;h4 id="cloud-platforms">Cloud Platforms&lt;/h4>
&lt;p>Self service cloud platforms where teams can get their own &amp;ldquo;landing zone&amp;rdquo; to create cloud infrastructure and deploy their applications in.&lt;/p>
&lt;h4 id="container-hosting-platforms">Container hosting platforms&lt;/h4>
&lt;p>Everyone uses Kubernetes nowadays.. Kubernetes does have many cool features but lets face it. It&amp;rsquo;s also really hard to maintain &amp;amp; make secure even if you use one of the managed offerings of the major cloud providers. Having this be managed by teams who also have to focus on business value will cost them a lot of effort they could spend on delivering business value.&lt;/p>
&lt;h4 id="api-management-platforms">Api management platforms&lt;/h4>
&lt;p>As a company you want to be sure that integrations with customers or 3rd parties are made in such a way that everything is consistent. A centralized API management platform helps in creating such a place that is the single entrace for your integration partners where DevOps teams can publish their APIs.&lt;/p>
&lt;h4 id="firewall-and-network-platforms">Firewall and network platforms&lt;/h4>
&lt;p>Creating a safe boundary around your network is often complex to make secure but still convinient for DevOps teams to use in an autonomous way. Creating a self service solution here can really help in making it possible for DevOps teams to expose their applications to the outside world without waiting for approvals or the networking team executing the changes for the DevOps team.&lt;/p>
&lt;h4 id="devops-tooling-platforms">DevOps tooling platforms&lt;/h4>
&lt;p>Teams need tools to build their software. In large organizations the teams that maintain these tools can become a bottleneck for other teams that actually want to use these tools. Self service enablement for onboarding, settings, offboarding can help reduce the wait for DevOps teams to get things done and can help in getting teams working on the golden path that helps in compliance &amp;amp; security.&lt;/p>
&lt;h4 id="iam-platforms">IAM Platforms&lt;/h4>
&lt;p>Within a company you want all applications to be able use the same identity for your users so they can use single sign on throughout the different applications. If you make it possible for teams to onboard their own apps to this identity platform.&lt;/p>
&lt;blockquote>
&lt;p>If you see some other examples of platform engineering teams let me know in the comments!&lt;/p>
&lt;/blockquote>
&lt;h3 id="conclusion">Conclusion&lt;/h3>
&lt;p>Platform engineering can be a great way to empower your DevOps teams to be more productive. Focus on making golden path implementations easier through self service but leave the responsibility on making choices at the DevOps teams. Internal platforms that are optional are the best way to go. If a team decides not to use it that&amp;rsquo;s fine. It does mean they have to own things like compliance &amp;amp; security themselves but if that is worth it for them it&amp;rsquo;s OK. Run your platform teams as internal products. have a product vision and treat your other internal teams as actual customers. A Platform engineering team should in the end just be another DevOps team that is responsible to build &amp;amp; run the platform as a product.&lt;/p>
&lt;p>I think the book &amp;ldquo;Team Topologies&amp;rdquo; does a great job in describing relations between teams. DevOps teams should act as &amp;ldquo;Stream aligned teams&amp;rdquo;. Focussing on a certain business capability. Platform teams should not act as a enabling team but rather just be a platform team that as i just said provides a platform that teams can choose to use. An SRE team could act in the form of &amp;ldquo;Enabling team&amp;rdquo; working together.&lt;/p>
&lt;p>
&lt;img src="https://fullcycledeveloper.com/img/team-topologies.png" alt="Platform Engineering meme">
&lt;/p>
&lt;p>My final conclusion is that all these things are ideas and concepts that &lt;em>should&lt;/em> help you deliver software &amp;amp; value to your end customers faster and with better quality. Therefore I see all of this as a form of DevOps instead of competing visions.&lt;/p></description></item><item><title>Hosting your HUGO blog on Github Pages in 1 hour</title><link>https://fullcycledeveloper.com/2022/02/07/Hosting-hugo-blog-on-github-pages/</link><pubDate>Mon, 07 Feb 2022 00:00:00 +0000</pubDate><guid>https://fullcycledeveloper.com/2022/02/07/Hosting-hugo-blog-on-github-pages/</guid><description>&lt;p>I started this blog a week ago and it&amp;rsquo;s actually my 3rd blog I created. I created my first blog around 2010 as self hosted wordpress website. Then when doing more Azure stuff I wanted to start of with a clean cheat again and created a new blog in 2016 using Wordpress again but then hosted on Azure &lt;a href="https://mobilefirstcloudfirst.net">https://mobilefirstcloudfirst.net&lt;/a>. This worked but I was never happy with it. The last 2 years I didn&amp;rsquo;t blog at all so when I started with my new years resolution of blogging again I decided I needed a new blog, new domain name and something that used markdown for editing.&lt;/p>
&lt;h2 id="choosing-hugo">Choosing Hugo&lt;/h2>
&lt;p>I chose Hugo after looking into some of the common blogging platforms that are based on static site generators such as Jekyll and Hugo. After browsing through some of the themes and did some comparison I decided to try out Hugo since it looked more popular and just wanted to see how ard it was.&lt;/p>
&lt;p>
&lt;img src="https://fullcycledeveloper.com/img/hugo-logo.svg" alt="HUGO">
&lt;/p>
&lt;p>A couple of hours later the website was up and running on my machine and I was already tweaking away at some UI improvements.. Point proven lets see what I needed to do.&lt;/p>
&lt;h2 id="my-blog-using-hugo-hosted-on-github-pages-what-is-in-the-box">My blog using Hugo hosted on Github Pages, what is in the box?&lt;/h2>
&lt;p>I wanted to create a blog website that was based on markdown files that i could store in git. I already had some experience with GitHub Pages so I though lets see how hard that is. After a couple of hours I had the followng up and running:&lt;/p>
&lt;ul>
&lt;li>Hugo CMS&lt;/li>
&lt;li>Finding a theme&lt;/li>
&lt;li>Algolia Search&lt;/li>
&lt;li>GitHub Pages for hosting&lt;/li>
&lt;li>Github discussions for comments using Giscuss&lt;/li>
&lt;li>Automatically deploy using Github Pages&lt;/li>
&lt;/ul>
&lt;h3 id="hugo-cms">Hugo CMS&lt;/h3>
&lt;p>The Hugo CMS was quite easy. I just followed the tutorial on the &lt;a href="https://gohugo.io">Hugo&lt;/a> website to create a new empty website. It took me a couple of minutes.&lt;/p>
&lt;h3 id="adding-a-theme">Adding a Theme&lt;/h3>
&lt;p>Hugo has a list of themes on it&amp;rsquo;s &lt;a href="https://themes.gohugo.io/">website&lt;/a>. The &lt;a href="https://themes.gohugo.io/themes/hugo-theme-cleanwhite/">Clean White Hugo Theme&lt;/a> looked quited good so I gave that a go. What I looked for in a theme was a nice clean interface and options for comments + search. This team had it all so I just installed it as a git submodule and when I ran the &lt;code>hugo serve&lt;/code> command it was working from the get go&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">mkdir themes
git submodule add https://github.com/zhaohuabing/hugo-theme-cleanwhite.git themes/hugo-theme-cleanwhite
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After my initial playing around with setting up the website I wanted to customize some things so what i did was that I actually forked the github repo and made the changes on my fork. All my changes are open source and can be found on &lt;a href="https://github.com/Geertvdc/hugo-theme-cleanwhite">this repo&lt;/a>&lt;/p>
&lt;p>Changes that I made are:&lt;/p>
&lt;ul>
&lt;li>Showing blog preview / full posts in the homepage instead of the really small summaries.&lt;/li>
&lt;li>Added headers to the blog preview using images&lt;/li>
&lt;li>Added an option to show banners on the sidebar.&lt;/li>
&lt;li>Some small css tweaks&lt;/li>
&lt;li>Added full posts to the RSS Feed instead of the summary&lt;/li>
&lt;li>Fixed some issues in the algolia search json that was being generated&lt;/li>
&lt;/ul>
&lt;p>All these changes were quite simple without me knowing anything about Hugo, themes or GO templating.&lt;/p>
&lt;h3 id="algolia-search">Algolia Search&lt;/h3>
&lt;p>Hugo does not have support for search out of the box by itself. Luckely the theme I chose had this covered and supported search by a free 3rd party service. The only thing that was needed was creating an account and set up the API key and create an index.&lt;/p>
&lt;p>
&lt;img src="https://fullcycledeveloper.com/img/Algolia-logo.png" alt="Algolia">
&lt;/p>
&lt;p>Algolia works with sending json files to the index. The json files are generated during compilation of the Hugo website and this json can then be uploaded on the website of Algolia for a first test. This manual labor is not something I would prefer so I automated this in the next step where I also deploy everything to Github Pages.&lt;/p>
&lt;h3 id="deploying-every-commit-to-github-pages-and-host-it-on-my-custom-domain">Deploying every commit to Github Pages and host it on my custom domain&lt;/h3>
&lt;p>
&lt;img src="https://fullcycledeveloper.com/img/gh-actions-pages.png" alt="Github Actions &amp;#43; Pages">
&lt;/p>
&lt;p>I&amp;rsquo;m a developer so I wanted a fully automated workflow. My content is stored in a git repo on Github and I wanted that every commit I made to &lt;code>main&lt;/code> would be automatically deployed to the website.&lt;/p>
&lt;p>GitHub offers this flow with no effort for Jekyll but for HUGO some small additions needed to be done. Before we create our workflow we need to add a specific file to our repo called &lt;code>CNAME&lt;/code> so github pages links this page to our custom domain.&lt;/p>
&lt;h4 id="cname-file">CNAME File&lt;/h4>
&lt;p>When you change the domain name for your website hosted using GitHub pages Github automatically creates a commit with a CNAME file in it. This file is used by GitHub to know which domain name is used for the website. Since my workflow was pushing all contents of the &lt;code>./public&lt;/code> folder GitHub was actually removing this file every time after the Hugo workflow ran. Manually adding the CNAME file to the &lt;code>static&lt;/code> folder helped solve this issue.&lt;/p>
&lt;p>My CNAME file content:&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-CNAME" data-lang="CNAME">fullcycledeveloper.com
&lt;/code>&lt;/pre>&lt;p>Now that everything is ready we can create our workflow file. My file looks like this, The steps are quite self explanatory but I&amp;rsquo;ve added some comments below each action to explain what I&amp;rsquo;m doing.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-Yaml" data-lang="Yaml">&lt;span style="color:#ff79c6">name&lt;/span>: github pages &lt;span style="color:#6272a4"># Name of the workflow&lt;/span>
&lt;span style="color:#ff79c6">on&lt;/span>:
&lt;span style="color:#ff79c6">push&lt;/span>:
&lt;span style="color:#ff79c6">branches&lt;/span>:
- main
&lt;span style="color:#ff79c6">pull_request&lt;/span>:
&lt;span style="color:#ff79c6">jobs&lt;/span>:
&lt;span style="color:#ff79c6">build&lt;/span>:
&lt;span style="color:#ff79c6">runs-on&lt;/span>: ubuntu-latest
&lt;span style="color:#ff79c6">defaults&lt;/span>:
&lt;span style="color:#ff79c6">run&lt;/span>:
&lt;span style="color:#ff79c6">working-directory&lt;/span>: blog
&lt;span style="color:#ff79c6">steps&lt;/span>:
- &lt;span style="color:#ff79c6">uses&lt;/span>: actions/checkout@v2
&lt;span style="color:#ff79c6">with&lt;/span>:
&lt;span style="color:#ff79c6">submodules&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span> &lt;span style="color:#6272a4"># Fetch Hugo themes (true OR recursive)&lt;/span>
&lt;span style="color:#ff79c6">fetch-depth&lt;/span>: &lt;span style="color:#bd93f9">0&lt;/span> &lt;span style="color:#6272a4"># Fetch all history for .GitInfo and .Lastmod&lt;/span>
- &lt;span style="color:#ff79c6">name&lt;/span>: Setup Hugo
&lt;span style="color:#ff79c6">uses&lt;/span>: peaceiris/actions-hugo@v2
&lt;span style="color:#ff79c6">with&lt;/span>:
&lt;span style="color:#ff79c6">hugo-version&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#39;latest&amp;#39;&lt;/span>
&lt;span style="color:#6272a4"># Downloads &amp;amp; installs HUGO cli&lt;/span>
- &lt;span style="color:#ff79c6">name&lt;/span>: Build
&lt;span style="color:#ff79c6">run&lt;/span>: hugo --minify
&lt;span style="color:#6272a4"># Do a HUGO build of your markdown files to generate a stetic website that is stored in the `./public` folder&lt;/span>
- &lt;span style="color:#ff79c6">name&lt;/span>: Deploy
&lt;span style="color:#ff79c6">uses&lt;/span>: peaceiris/actions-gh-pages@v3
&lt;span style="color:#ff79c6">if&lt;/span>: github.ref == &amp;#39;refs/heads/main&amp;#39;
&lt;span style="color:#ff79c6">with&lt;/span>:
&lt;span style="color:#ff79c6">github_token&lt;/span>: ${{ secrets.GITHUB_TOKEN }}
&lt;span style="color:#ff79c6">publish_dir&lt;/span>: ./blog/public
&lt;span style="color:#6272a4"># takes the public folder and pushes the changes to a new branch called gh-pages&lt;/span>
- &lt;span style="color:#ff79c6">uses&lt;/span>: wangchucheng/algolia-uploader@master
&lt;span style="color:#ff79c6">with&lt;/span>:
&lt;span style="color:#ff79c6">app_id&lt;/span>: 9AWS4CUHVW
&lt;span style="color:#ff79c6">admin_key&lt;/span>: ${{ secrets.ALGOLIA_ADMIN_KEY }}
&lt;span style="color:#ff79c6">index_name&lt;/span>: fullcycledeveloper-blog
&lt;span style="color:#ff79c6">index_file_path&lt;/span>: ./blog/public/algolia.json
&lt;span style="color:#6272a4"># Uploads the algolia json file to the index on algolia website&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After each commit the generated website is pushed to the &lt;code>gh-pages&lt;/code> branch. From here we can enable Github Pages in the Settings menu of the repository. Point it to the right branch and connect the domain name that you specified in the CNAME file. You&amp;rsquo;ll have to do some DNS settings to make sure you are the actual owner of that domain and voila your website is ready to go!&lt;/p>
&lt;p>
&lt;img src="https://fullcycledeveloper.com/img/gh-pages-settings.png" alt="Github Pages settings">
&lt;/p>
&lt;h3 id="adding-comments-to-the-posts-using-giscuss-based-on-github-discussions">Adding comments to the posts using Giscuss (based on Github Discussions)&lt;/h3>
&lt;p>A static website by default is just static.. That is ok for most scenarios but for a blog I wanted to add comments to the posts. I used Giscuss to do that. The Hugo Theme I used (&lt;a href="https://themes.gohugo.io/themes/hugo-theme-cleanwhite/">Clean White Hugo Theme&lt;/a> ) has built in support for multiple comment systems. Since my main target audience is developers I chose Giscuss as the comment system.&lt;/p>
&lt;p>The only thing i needed to do is set the properties to the right Github Discussions space in my configuration .toml file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-toml" data-lang="toml">[params.giscus]
data_repo=&lt;span style="color:#f1fa8c">&amp;#34;geertvdc/geertvdc.github.io&amp;#34;&lt;/span>
data_repo_id=&lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;REPO_ID&amp;gt;&amp;#34;&lt;/span>
data_category=&lt;span style="color:#f1fa8c">&amp;#34;blog-comments&amp;#34;&lt;/span>
data_category_id=&lt;span style="color:#f1fa8c">&amp;#34;&amp;lt;CATEGORY_ID&amp;gt;&amp;#34;&lt;/span>
data_mapping=&lt;span style="color:#f1fa8c">&amp;#34;blog&amp;#34;&lt;/span>
data_reactions_enabled=&lt;span style="color:#f1fa8c">&amp;#34;1&amp;#34;&lt;/span>
data_emit_metadata=&lt;span style="color:#f1fa8c">&amp;#34;0&amp;#34;&lt;/span>
data_theme=&lt;span style="color:#f1fa8c">&amp;#34;light&amp;#34;&lt;/span>
data_lang=&lt;span style="color:#f1fa8c">&amp;#34;en&amp;#34;&lt;/span>
crossorigin=&lt;span style="color:#f1fa8c">&amp;#34;anonymous&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After doing that it just works! I didn&amp;rsquo;t have to sign up for any new platform since my code is already on Github and now everything is in the same place.&lt;/p>
&lt;p>Hopefully this helps people set up a simple blog website as well. I&amp;rsquo;m really happy in how it turned out and it really was a breeze to set it up.&lt;/p>
&lt;p>Happy Blogging!&lt;/p>
&lt;p>Geert van der Cruijsen&lt;/p></description></item><item><title>Generating sandbox APIs for your ASP.Net Core Web APIs</title><link>https://fullcycledeveloper.com/2022/01/18/generate-sandbox-apis/</link><pubDate>Tue, 18 Jan 2022 00:00:00 +0000</pubDate><guid>https://fullcycledeveloper.com/2022/01/18/generate-sandbox-apis/</guid><description>&lt;p>When building APIs I often want to share my contract as soon as possible. Especially when you know your consumers and are you&amp;rsquo;re open for feedback and discussion on the contract of the API.&lt;/p>
&lt;h2 id="contract-first-or-code-first">Contract first or Code first?&lt;/h2>
&lt;p>Although I want to share my contract as soon as possible I don&amp;rsquo;t like these API contract designer tools. My approach is often just creating an empty API in Asp.Net Core by defining the controllers and classes that define the contract. Adding &lt;a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">Swashbuckle&lt;/a> to your project will generate a Swagger file / Open API Spec based on the controllers and classes that you can use to document your API.&lt;/p>
&lt;h2 id="giving-your-consumers-a-testable-solution-as-soon-as-possible">Giving your consumers a testable solution as soon as possible&lt;/h2>
&lt;p>So an early API specification / contract is quite easy to create. But what if what if we could actually generate a working API from this specification that returns fake data? There are certain tools that can do this for you like &lt;a href="https://github.com/jormaechea/open-api-mocker">Open API Mock&lt;/a>. This tool can generate a working API from an API specification and return fake data based on additional extension properties in the specification.&lt;/p>
&lt;p>Let&amp;rsquo;s take a look at a basic swagger file (weather forecast from the built in template when you create a new Asp.Net Core Web API Project). I&amp;rsquo;ve added some extension properties (&lt;code>x-faker&lt;/code>) to the specification by hand so Open API Mock knows what kind of fake data it should generate. Open API Mock generates this data through a library called &lt;a href="https://github.com/faker-js/faker">Faker&lt;/a>. It has a wide range of fake data generators from numbers, to street names, phone numbers, bank details etc. Also available in many country specific variants.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">&lt;span style="color:#f1fa8c">&amp;#34;schemas&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;WeatherForecast&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;object&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;date&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;string&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;format&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;date-time&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;x-faker&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;date.recent&amp;#34;&lt;/span>
},
&lt;span style="color:#ff79c6">&amp;#34;temperatureC&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;integer&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;format&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;int32&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;x-faker&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;datatype.number(-10,35)&amp;#34;&lt;/span>
},
&lt;span style="color:#ff79c6">&amp;#34;temperatureF&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;integer&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;format&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;int32&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;readOnly&amp;#34;&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;x-faker&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;datatype.number(105)&amp;#34;&lt;/span>
},
&lt;span style="color:#ff79c6">&amp;#34;summary&amp;#34;&lt;/span>: {
&lt;span style="color:#ff79c6">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;string&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;nullable&amp;#34;&lt;/span>: &lt;span style="color:#ff79c6">true&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;x-faker&amp;#34;&lt;/span>: &lt;span style="color:#f1fa8c">&amp;#34;lorem.paragraph&amp;#34;&lt;/span>
}
},
&lt;span style="color:#ff79c6">&amp;#34;additionalProperties&amp;#34;&lt;/span>: &lt;span style="color:#ff79c6">false&lt;/span>
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>We can now use this swagger file and feed it to Open API Mock to generate a working API by using Docker to run the Open API Mock container.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">docker run -v &lt;span style="color:#f1fa8c">&amp;#34;[path to your]swagger.json:/app/schema.json&amp;#34;&lt;/span> -p &lt;span style="color:#f1fa8c">&amp;#34;8080:5000&amp;#34;&lt;/span> jormaechea/open-api-mocker
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now when we test this API you&amp;rsquo;ll see that Open API Mock returns fake data specified in the faker extension properties of the specification.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-json" data-lang="json">[
{
&lt;span style="color:#ff79c6">&amp;#34;date&amp;#34;&lt;/span>:&lt;span style="color:#f1fa8c">&amp;#34;2022-01-05T22:25:30.366Z&amp;#34;&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;temperatureC&amp;#34;&lt;/span>:&lt;span style="color:#bd93f9">-6&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;temperatureF&amp;#34;&lt;/span>:&lt;span style="color:#bd93f9">41&lt;/span>,
&lt;span style="color:#ff79c6">&amp;#34;summary&amp;#34;&lt;/span>:&lt;span style="color:#f1fa8c">&amp;#34;Praesentium iste natus temporibus omnis nihil perspiciatis quo. Rerum odit blanditiis quia autem et earum magnam quod. Suscipit voluptate quia voluptatibus ea reiciendis. Sed praesentium sed in est.&amp;#34;&lt;/span>
}
]
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="adding-this-functionality-automatically-to-your-swashbuckle-generated-swagger-file">Adding this functionality automatically to your Swashbuckle generated swagger file&lt;/h2>
&lt;p>So manually adding a swagger file is nice but what if you want to add this functionality automatically to your swagger file when it&amp;rsquo;s being generated by Swashbuckle? I&amp;rsquo;ve created a small extension to Swashbuckle, published through Nuget called &lt;a href="https://www.nuget.org/packages/Swashbuckle.AspNetCore.ExtensionProperties/">Swashbuckle.AspNetCore.ExtensionProperties&lt;/a>. What this allows you to do is to add attributes to your classes that are used in the Open API Specification that is generated by Swashbuckle.&lt;/p>
&lt;p>If you install the Nuget package you can add attributes in the following way:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-C#" data-lang="C#">&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#ff79c6">class&lt;/span> &lt;span style="color:#50fa7b">WeatherForecast&lt;/span>
{
&lt;span style="color:#50fa7b"> [Faker(fakerValue:&amp;#34;date.recent&amp;#34;)]&lt;/span>
&lt;span style="color:#ff79c6">public&lt;/span> DateTime Date { &lt;span style="color:#ff79c6">get&lt;/span>; &lt;span style="color:#ff79c6">set&lt;/span>; }
&lt;span style="color:#50fa7b">
&lt;/span>&lt;span style="color:#50fa7b"> [Faker(fakerValue:&amp;#34;datatype.number(-10,35)&amp;#34;)]&lt;/span>
&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> TemperatureC { &lt;span style="color:#ff79c6">get&lt;/span>; &lt;span style="color:#ff79c6">set&lt;/span>; }
&lt;span style="color:#50fa7b">
&lt;/span>&lt;span style="color:#50fa7b"> [Faker(fakerValue:&amp;#34;datatype.number(105)&amp;#34;)]&lt;/span>
&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#8be9fd">int&lt;/span> TemperatureF =&amp;gt; &lt;span style="color:#bd93f9">32&lt;/span> + (&lt;span style="color:#8be9fd">int&lt;/span>)(TemperatureC / &lt;span style="color:#bd93f9">0.5556&lt;/span>);
&lt;span style="color:#50fa7b">
&lt;/span>&lt;span style="color:#50fa7b"> [Faker(fakerValue:&amp;#34;lorem.paragraph&amp;#34;)]&lt;/span>
&lt;span style="color:#ff79c6">public&lt;/span> &lt;span style="color:#8be9fd">string?&lt;/span> Summary { &lt;span style="color:#ff79c6">get&lt;/span>; &lt;span style="color:#ff79c6">set&lt;/span>; }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Generating the specification file by running the API will result in the exact same json as mentioned earlier in this post.&lt;/p>
&lt;p>The source of this nuget package is open source and can be found on my &lt;a href="https://github.com/geertvdc/Swashbuckle.AspNetCore.ExtensionProperties">Github repo&lt;/a>. It can also be used to add other types of extension properties that you might want to add to your specification file for other tools that process your swagger files.&lt;/p>
&lt;p>So whenever we would start a new API Project we could have a running sandbox solution that returns fake data for our API in only a few minutes by just following the following steps mentioned earlier:&lt;/p>
&lt;ol>
&lt;li>Create a new Asp.Net Core Web API Project with Controllers + Classes&lt;/li>
&lt;li>Add &lt;a href="https://github.com/domaindrivendev/Swashbuckle.AspNetCore">Swashbuckle&lt;/a> to the project&lt;/li>
&lt;li>Add the &lt;a href="https://www.nuget.org/packages/Swashbuckle.AspNetCore.ExtensionProperties/">Swashbuckle.AspNetCore.ExtensionProperties&lt;/a> NuGet package to the project&lt;/li>
&lt;li>Add &lt;code>Faker&lt;/code> attributes to your properties in your Classes.&lt;/li>
&lt;li>Extract the .json file from your API by running the API and browsing to the Swagger UI on &lt;code>[api]/swagger/&lt;/code>&lt;/li>
&lt;li>Run the Open API Mock using your swagger file&lt;/li>
&lt;/ol>
&lt;h2 id="using-this-in-automation--pipelines-and-automatically-posting-it-to-azure-api-management">Using this in Automation / pipelines and automatically posting it to Azure API Management&lt;/h2>
&lt;p>The steps above are quite easy to do but I always try to set up all deployments through continous delivery pipelines. So what I like to do for every change made to the API is to automatically deploy it&amp;rsquo;s specification to Azure API Management. There is quite some information on how to do this either by infrastructure as code tech such as ARM or TerraForm but also using the Azure CLI or Powershell. I&amp;rsquo;ll skip on the basics of how to import an API to API management but would like to focus on how you could work with both a sandbox and the actual API.&lt;/p>
&lt;h3 id="blogs--documentation-on-azure-api-management-deployments-from-delivery-pipelines">Blogs &amp;amp; documentation on Azure API Management deployments from delivery pipelines.&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://mobilefirstcloudfirst.net/2017/07/setting-continuous-delivery-azure-api-management-vsts/">https://mobilefirstcloudfirst.net/2017/07/setting-continuous-delivery-azure-api-management-vsts/&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.microsoft.com/en-us/azure/api-management/devops-api-development-templates">https://docs.microsoft.com/en-us/azure/api-management/devops-api-development-templates&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mscloud.be/azure/Update-API-in-APIM-from-Azure-Devops/">https://mscloud.be/azure/Update-API-in-APIM-from-Azure-Devops/&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="sandboxes-in-azure-api-management">Sandboxes in Azure API Management.&lt;/h3>
&lt;p>Azure API management has the notion of &amp;ldquo;Products&amp;rdquo;. These products are a way you can group certain APIs together and give a specific audience access to these APIs. When working with sandboxes I always prefer to create 2 products, one for the sandbox APIs and one for the actual APIs. This way you have 2 APIs for each of your API. 1 sandbox API in the sandbox product and 1 actual API in the production product.&lt;/p>
&lt;p>Sandboxes are APIs that do not contain any real data so opening them up for everyone is a best practice so people can get inspired by browsing through the API list and playing around with them.&lt;/p>
&lt;h3 id="how-to-easily-get-the-open-api-specification-from-a-aspnet-core-web-api-project-in-a-pipeline">How to easily get the Open API Specification from a ASP.Net Core Web API project in a pipeline&lt;/h3>
&lt;p>The Swashbuckle project comes with a CLI tool to download the Open API specification file with a simple command. You can download and use the Swashbuckle.AspNetCore.Cli tool by running the following command:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">dotnet tool install -g --version 6.2.3 Swashbuckle.AspNetCore.Cli
swagger tofile --output swagger.json YourApi/bin/Debug/net6.0/YourApi.dll &lt;span style="color:#f1fa8c">&amp;#34;v1&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>After extracting the Open API Specification file you can now pass it into the Open API Mock container and spin that container up somewhere in the cloud on for example an Azure Container Instance, an Azure Web App for Containers or an AKS cluster if you are already using those. After that hook up the Azure API Management backend to your mock and you&amp;rsquo;re ready to go.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>Hopefully this post, the nuget package and other tools I mentioned helps in shifting left the communication of API designs with your consumers so they have an early view on the contract but also an actual working API sandbox.&lt;/p>
&lt;p>Geert van der Cruijsen&lt;/p></description></item><item><title>Hello world!</title><link>https://fullcycledeveloper.com/2022/01/14/hello-world/</link><pubDate>Fri, 14 Jan 2022 00:00:00 +0000</pubDate><guid>https://fullcycledeveloper.com/2022/01/14/hello-world/</guid><description>&lt;p>As a software developer there is only 1 title you can use to create your first post on a new blog. &amp;ldquo;Hello World!&amp;rdquo;. ðŸ‘‹&lt;/p>
&lt;h3 id="so-why-this-blog">So why this blog?&lt;/h3>
&lt;p>It&amp;rsquo;s actually my 3rd blog website I created. I started of years ago with a blog using Wordpress that I hosted myself. Then about 6 years ago I was working a lot with Azure and wanted to move away from self hosting so I created a new blog (still using Wordpress) but then hosted on Azure. This worked quite well at that time but I lost passion for blogging a couple of years ago.&lt;/p>
&lt;p>Now I wanted to start writing some blogposts again so I had 2 options: dust of my old blog or create a new one. I never really liked the whole Wordpress experience and wanted to move to a static site generator so this was the right time to make the switch to &lt;a href="https://gohugo.io/">Hugo&lt;/a> hosted on &lt;a href="https://pages.github.com/">Github Pages&lt;/a>.&lt;/p>
&lt;p>The source of this blog can be found here on my &lt;a href="https://github.com/geertvdc/geertvdc.github.io">Github Repo: Geertvdc/geertvdc.github.io&lt;/a>.&lt;/p>
&lt;h3 id="full-cycle-developer">Full cycle developer?&lt;/h3>
&lt;p>As my dayjob I work as a Senior Consultant at Xpirit where I help companies build better software. I do this by improving the Engineering culture, introduce new technology and coaching employees from CTOs to Developers. I believe that building the best software is done by teams who follow the DevOps mantra: &amp;ldquo;You build it, you run it!&amp;rdquo;. I love this mantra and try to improve teams on all aspects from architecture, design, implementation, testing, deployments, maintenance, and support. That&amp;rsquo;s why I called this blog &amp;ldquo;The full cycle developer blog&amp;rdquo;.&lt;/p>
&lt;h3 id="sharing-knowledge">Sharing Knowledge&lt;/h3>
&lt;p>Sharing Knowledge is one of my passions. Either by writing articles or blogposts but also by public speaking at international conferences and meetups.&lt;/p>
&lt;h3 id="what-to-expect-on-this-blog">What to expect on this blog?&lt;/h3>
&lt;p>Posts by me on this blog can cover all aspects of software development from technical posts about a certain technology to non technical posts about organizational culture or personal development.&lt;/p>
&lt;h3 id="so-who-am-i">So who am I?&lt;/h3>
&lt;p>My name is Geert van der Cruijsen. I&amp;rsquo;m a senior consultant working at Xpirit in the Netherlands but more important i&amp;rsquo;m also a husband of my wife Patty and father of my daughters Lauren &amp;amp; Amber.&lt;/p></description></item></channel></rss>